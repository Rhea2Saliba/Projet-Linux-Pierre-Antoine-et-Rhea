import yfinance as yf
import pandas as pd
import numpy as np

# --- 1. FONCTIONS DE PERFORMANCE (ASSUREZ-VOUS QUE CES FONCTIONS SONT BIEN DÉFINIES AU DÉBUT !) ---

def calculate_max_drawdown(cumulative_returns):
    peak = cumulative_returns.expanding(min_periods=1).max()
    drawdown = (cumulative_returns - peak) / peak
    return abs(drawdown.min()) 

def calculate_sharpe_ratio(daily_returns, risk_free_rate=0.03, annualization_factor=252):
    daily_returns = daily_returns[daily_returns != 0].dropna()
    mean_return = daily_returns.mean()
    std_dev_return = daily_returns.std()
    daily_risk_free_rate = (1 + risk_free_rate)**(1/annualization_factor) - 1
    sharpe_ratio = (mean_return - daily_risk_free_rate) / std_dev_return * np.sqrt(annualization_factor)
    return sharpe_ratio

# --- 2. CONFIGURATION ET RÉCUPÉRATION DES DONNÉES ---
ticker_symbol = '^GSPC'
start_date = '2020-01-01'
end_date = pd.to_datetime('today').strftime('%Y-%m-%d')
initial_investment = 100 

print(f"--- Démarrage de l'analyse Buy-and-Hold pour le {ticker_symbol} ({start_date} à {end_date}) ---")

try:
    data = yf.download(ticker_symbol, start=start_date, end=end_date)
    asset_prices = data[['Close']].copy() # Utilisez .copy() pour éviter SettingWithCopyWarning
    asset_prices.columns = [ticker_symbol]

except Exception as e:
    print(f"Erreur fatale lors de la récupération des données : {e}")
    exit() 

# --- 3. STRATÉGIE BUY-AND-HOLD ---

# Calcul des rendements journaliers (CORRECTION DE LA NAMEERROR)
daily_returns = asset_prices[ticker_symbol].pct_change().fillna(0)

# Calcul de la valeur cumulative de la stratégie Buy-and-Hold
cumulative_value_buy_hold = (1 + daily_returns).cumprod() * initial_investment
cumulative_value_buy_hold.name = 'Buy_and_Hold_Value'

# --- 4. PRÉPARATION DES DONNÉES POUR LE DASHBOARD ---

# Normalisation du prix brut pour la comparaison (base 100)
normalized_raw_price = (asset_prices[ticker_symbol] / asset_prices[ticker_symbol].iloc[0]) * initial_investment
normalized_raw_price.name = 'Raw_Price_Value'

# DataFrame final pour le graphique
final_df = pd.concat([normalized_raw_price, cumulative_value_buy_hold], axis=1)

# --- 5. CALCUL ET AFFICHAGE DES MÉTRIQUES (Buy-and-Hold) ---
max_dd_bh = calculate_max_drawdown(cumulative_value_buy_hold)
sharpe_bh = calculate_sharpe_ratio(daily_returns, risk_free_rate=0.03) 
print(f"\n--- Performance Buy-and-Hold ---")
print(f"Sharpe Ratio : {sharpe_bh:.2f}, Max Drawdown : {max_dd_bh:.2%}")

# --- 6. IMPLÉMENTATION DE LA STRATÉGIE DE MOMENTUM (MMS) ---
WINDOW_SIZE = 50 
STRATEGY_NAME = 'Momentum_50D_MMS'

# 1. Calculer la Moyenne Mobile Simple (MMS)
# Correction : Utilisation de .loc pour éviter le SettingWithCopyWarning
asset_prices.loc[:, 'MMS_50'] = asset_prices[ticker_symbol].rolling(window=WINDOW_SIZE).mean()

# 2. Générer le signal de trading (Signal)
# Correction : Utilisation de .loc pour éviter le SettingWithCopyWarning
asset_prices.loc[:, 'Signal'] = np.where(asset_prices[ticker_symbol] > asset_prices['MMS_50'], 1.0, 0.0)

# 3. Calculer les rendements de la stratégie
# On utilise les rendements journaliers (daily_returns) qui sont maintenant définis !
strategy_returns = daily_returns.shift(-1) * asset_prices['Signal'].shift(1)
strategy_returns = strategy_returns.fillna(0)

# 4. Calculer la valeur cumulative de la stratégie de Momentum
cumulative_value_momentum = (1 + strategy_returns).cumprod() * initial_investment
cumulative_value_momentum.name = STRATEGY_NAME


# --- 7. MISE À JOUR DU DASHBOARD ET DES MÉTRIQUES ---

# A. Mettre à jour le DataFrame final pour le graphique
final_df[STRATEGY_NAME] = cumulative_value_momentum

# B. Calculer les métriques pour la stratégie Momentum
max_dd_mom = calculate_max_drawdown(cumulative_value_momentum)
sharpe_mom = calculate_sharpe_ratio(strategy_returns, risk_free_rate=0.03)

print("\n--- Aperçu des performances de la stratégie Momentum ---")
print(f"Sharpe Ratio annualisé : {sharpe_mom:.2f}, Max Drawdown : {max_dd_mom:.2%}") 
print(f"Performance Totale: {(cumulative_value_momentum.iloc[-1] - initial_investment) / initial_investment:.2%}")

print("\n--- Tableau de comparaison (dernières lignes) ---")
print(final_df[['Raw_Price_Value', 'Buy_and_Hold_Value', STRATEGY_NAME]].tail())

# Continuer à partir du DataFrame 'asset_prices', 'daily_returns', et 'initial_investment'

# --- 8. IMPLÉMENTATION DE LA STRATÉGIE DE CROISEMENT DE MMS ---

# Définir les paramètres
SHORT_WINDOW = 20  # MMS Courte (Rapide)
LONG_WINDOW = 100  # MMS Longue (Lente)
STRATEGY_NAME_CROSS = f'Cross_MMS_{SHORT_WINDOW}_{LONG_WINDOW}'

# 1. Calculer les deux Moyennes Mobiles
asset_prices.loc[:, 'MMS_Short'] = asset_prices[ticker_symbol].rolling(window=SHORT_WINDOW).mean()
asset_prices.loc[:, 'MMS_Long'] = asset_prices[ticker_symbol].rolling(window=LONG_WINDOW).mean()

# 2. Générer le signal de trading initial
# Signal initial : 1.0 (Achat) si MMS Courte > MMS Longue, 0.0 (Neutre) sinon
asset_prices.loc[:, 'Signal_Cross'] = np.where(asset_prices['MMS_Short'] > asset_prices['MMS_Long'], 1.0, 0.0)

# 3. Calculer les positions (Pour simuler l'entrée/sortie, on décale le signal)
# On prend le signal à partir du jour où le croisement s'est produit
# On garde la position du jour précédent si le signal n'a pas changé.
# Pandas .diff() permet de trouver quand le signal est passé de 0 à 1 ou de 1 à 0.
# Cependant, pour simplifier, on utilise simplement le signal décalé d'un jour.
strategy_returns_cross = daily_returns.shift(-1) * asset_prices['Signal_Cross'].shift(1)
strategy_returns_cross = strategy_returns_cross.fillna(0)

# 4. Calculer la valeur cumulative de la stratégie de Croisement
cumulative_value_cross = (1 + strategy_returns_cross).cumprod() * initial_investment
cumulative_value_cross.name = STRATEGY_NAME_CROSS

# --- 9. MISE À JOUR DU DASHBOARD ET DES MÉTRIQUES ---

# A. Mettre à jour le DataFrame final pour le graphique
final_df[STRATEGY_NAME_CROSS] = cumulative_value_cross

# B. Calculer les métriques
max_dd_cross = calculate_max_drawdown(cumulative_value_cross)
sharpe_cross = calculate_sharpe_ratio(strategy_returns_cross, risk_free_rate=0.03)

print("\n--- Aperçu des performances de la stratégie Croisement MMS ---")
print(f"Sharpe Ratio annualisé : {sharpe_cross:.2f}, Max Drawdown : {max_dd_cross:.2%}") 
print(f"Performance Totale: {(cumulative_value_cross.iloc[-1] - initial_investment) / initial_investment:.2%}")

print("\n--- Tableau de comparaison final (dernières lignes) ---")
print(final_df[['Buy_and_Hold_Value', 'Momentum_50D_MMS', STRATEGY_NAME_CROSS]].tail())

# Continuer à partir du DataFrame 'asset_prices', 'daily_returns', et 'initial_investment'

# --- 10. IMPLÉMENTATION DE LA STRATÉGIE DE BANDES DE BOLLINGER ---

# Définir les paramètres
BB_WINDOW = 20  # Période de la MMS et du calcul de l'écart-type
N_STD_DEV = 2.0 # Multiplicateur de l'écart-type (souvent 2)
STRATEGY_NAME_BB = f'Bollinger_Bands_{BB_WINDOW}D'

# 1. Calculer les Bandes de Bollinger
# Bande Moyenne (MMS)
asset_prices.loc[:, 'BB_Mid'] = asset_prices[ticker_symbol].rolling(window=BB_WINDOW).mean()
# Écart-type (Volatility)
asset_prices.loc[:, 'BB_Std'] = asset_prices[ticker_symbol].rolling(window=BB_WINDOW).std()
# Bandes Supérieure et Inférieure
asset_prices.loc[:, 'BB_Upper'] = asset_prices['BB_Mid'] + (asset_prices['BB_Std'] * N_STD_DEV)
asset_prices.loc[:, 'BB_Lower'] = asset_prices['BB_Mid'] - (asset_prices['BB_Std'] * N_STD_DEV)

# 2. Générer le Signal de Trading (Logique de Réversion à la Moyenne)

# 2a. Signal d'ENTRÉE (Achat) : Le prix est inférieur à la Bande Inférieure
# On utilise une colonne temporaire pour marquer les jours d'entrée
asset_prices.loc[:, 'Entry_Signal'] = np.where(asset_prices[ticker_symbol] < asset_prices['BB_Lower'], 1.0, 0.0)

# 2b. Maintenir/Sortir : Définir la position (1 pour position ouverte, 0 pour neutre)
# Ici, nous allons simplifier : si le prix est en dessous de la bande moyenne, la position est maintenue.
# Sinon, elle est fermée. (Ceci est une des nombreuses façons de gérer la sortie)
asset_prices.loc[:, 'Position'] = asset_prices['Entry_Signal'].replace(to_replace=0.0, method='ffill')
asset_prices.loc[:, 'Position'] = np.where(asset_prices[ticker_symbol] > asset_prices['BB_Mid'], 0.0, asset_prices['Position'])
asset_prices.loc[:, 'Position'] = asset_prices['Position'].fillna(0)


# 3. Calculer les rendements de la stratégie
# Rendement Stratégie = Rendements Journaliers * Position décalée d'un jour
strategy_returns_bb = daily_returns.shift(-1) * asset_prices['Position'].shift(1)
strategy_returns_bb = strategy_returns_bb.fillna(0)

# 4. Calculer la valeur cumulative de la stratégie des Bandes de Bollinger
cumulative_value_bb = (1 + strategy_returns_bb).cumprod() * initial_investment
cumulative_value_bb.name = STRATEGY_NAME_BB

# --- 11. MISE À JOUR DU DASHBOARD ET DES MÉTRIQUES ---

# A. Mettre à jour le DataFrame final pour le graphique
final_df[STRATEGY_NAME_BB] = cumulative_value_bb

# B. Calculer les métriques
max_dd_bb = calculate_max_drawdown(cumulative_value_bb)
sharpe_bb = calculate_sharpe_ratio(strategy_returns_bb, risk_free_rate=0.03)

print("\n--- Aperçu des performances de la stratégie Bandes de Bollinger ---")
print(f"Sharpe Ratio annualisé : {sharpe_bb:.2f}, Max Drawdown : {max_dd_bb:.2%}") 
print(f"Performance Totale: {(cumulative_value_bb.iloc[-1] - initial_investment) / initial_investment:.2%}")

print("\n--- Tableau de comparaison final (4 stratégies) ---")
print(final_df[['Buy_and_Hold_Value', 'Momentum_50D_MMS', STRATEGY_NAME_CROSS, STRATEGY_NAME_BB]].tail())